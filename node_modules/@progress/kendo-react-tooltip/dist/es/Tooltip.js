var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as PropTypes from 'prop-types';
import { dispatchEvent, classNames } from '@progress/kendo-react-common';
import { getLeftPosition, getTopPosition, getDomRect, isTooltipElement } from './utils';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from './package-metadata';
var Tooltip = /** @class */ (function (_super) {
    __extends(Tooltip, _super);
    function Tooltip(props) {
        var _this = _super.call(this, props) || this;
        /**
         * @hidden
         */
        _this.state = {
            targetElement: null,
            open: false
        };
        _this.title = '';
        _this.top = 0;
        _this.left = 0;
        _this.willOpen = false;
        /**
         * The method is used on the MouseOut event to hide the Tooltip.
         */
        _this.handleMouseOut = function (event) {
            var element = document.elementFromPoint(event.clientX, event.clientY);
            if (isTooltipElement(element)) {
                return;
            }
            if (_this.props.open) {
                return;
            }
            _this.willOpen = false;
            dispatchEvent(_this.props.onClose, event, _this, undefined);
            _this.setState({ targetElement: null, open: false });
        };
        /**
         * Used on the `MouseOver` event to show the Tooltip.
         */
        _this.handleMouseOver = function (event) {
            var target = event.target;
            if (!_this.isVisible(target) || isTooltipElement(target) || target === _this.state.targetElement) {
                return;
            }
            _this.showToolTip(event);
            dispatchEvent(_this.props.onOpen, event, _this, undefined);
        };
        _this.handleBodyMousemove = function (event) {
            _this.top = event.clientY;
            _this.left = event.clientX;
        };
        _this.position = function (element) {
            var domRect = getDomRect(_this.state.targetElement);
            var left = getLeftPosition(_this.left, element.offsetWidth, domRect, _this.props.anchorElement, _this.props.position);
            var top = getTopPosition(_this.top, domRect, element.offsetHeight, _this.props.anchorElement, _this.props.position);
            return { left: left, top: top };
        };
        _this.getTitle = function (element) {
            while (element) {
                if (element.title || element.titleExpando) {
                    return element.title || element.titleExpando;
                }
                element = _this.props.parentTitle && element.parentElement || null;
            }
            return '';
        };
        _this.calloutClassName = function () {
            switch (_this.props.position) {
                case 'bottom':
                    return 'k-callout k-callout-n';
                case 'left':
                    return 'k-callout k-callout-e';
                case 'right':
                    return 'k-callout k-callout-w';
                case 'top':
                    return 'k-callout k-callout-s';
                default:
                    return _this.top < (window.innerHeight / 2) ? 'k-callout k-callout-n' : 'k-callout k-callout-s';
            }
        };
        validatePackage(packageMetadata);
        return _this;
    }
    /**
     * @hidden
     */
    Tooltip.prototype.componentDidMount = function () {
        if (document) {
            document.body.addEventListener('mousemove', this.handleBodyMousemove);
        }
    };
    /**
     * @hidden
     */
    Tooltip.prototype.componentWillUnmount = function () {
        clearTimeout(this.openTimeout);
        this.openTimeout = undefined;
        if (document) {
            document.body.removeEventListener('mousemove', this.handleBodyMousemove);
        }
    };
    /**
     * @hidden
     */
    Tooltip.prototype.componentDidUpdate = function () {
        if (this.props.open && this.props.targetElement) {
            this.showToolTip({ target: this.props.targetElement });
        }
    };
    /**
     * @hidden
     */
    Tooltip.prototype.render = function () {
        var _this = this;
        if (this.props.children) {
            var _a = this.props, children = _a.children, options = __rest(_a, ["children"]);
            var tooltip_1 = null;
            return (React.createElement("div", { onMouseOver: function (event) { if (tooltip_1) {
                    tooltip_1.handleMouseOver(event);
                } }, onMouseOut: function (event) { if (tooltip_1) {
                    tooltip_1.handleMouseOut(event);
                } } },
                React.createElement(Tooltip, __assign({ ref: function (el) { return tooltip_1 = el; } }, options)),
                children));
        }
        if (this.props.open === false) {
            return null;
        }
        return this.state.targetElement &&
            this.title &&
            document &&
            ReactDOM.createPortal((React.createElement("div", { ref: function (el) {
                    if (!el) {
                        return;
                    }
                    var position = _this.position(el);
                    el.style.left = position.left + 'px';
                    el.style.top = position.top + 'px';
                }, className: classNames('k-animation-container', 'k-animation-container-fixed', 'k-animation-container-shown', this.props.className), style: this.props.style, tabIndex: 0 },
                React.createElement("div", { className: classNames('k-tooltip', this.props.tooltipClassName), style: __assign({ position: 'relative' }, this.props.tooltipStyle) },
                    React.createElement("div", { className: "k-tooltip-content" }, this.props.content &&
                        React.createElement(this.props.content, { title: this.title, target: this.state.targetElement })
                        || this.title),
                    this.props.showCallout && React.createElement("div", { ref: function (el) {
                            if (!el) {
                                return;
                            }
                            el.className = _this.calloutClassName();
                            if (_this.props.position === 'auto') {
                                _this.left < (window.screen.availWidth / 2)
                                    ? el.style.left = _this.props.setCalloutOnPositionAuto || '25%'
                                    : el.style.left = _this.props.setCalloutOnPositionAuto || '75%';
                            }
                        } })))), this.props.appendTo ? this.props.appendTo : document.body);
    };
    Tooltip.prototype.showToolTip = function (event) {
        var _this = this;
        var target = this.props.targetElement || event.target;
        clearTimeout(this.openTimeout);
        this.title = this.getTitle(target);
        if (this.title) {
            target.titleExpando = target.titleExpando || target.title;
            target.title = '';
        }
        this.willOpen = true;
        if (!this.props.openDelay) {
            this.setState({ targetElement: target, open: true });
        }
        else {
            this.openTimeout = window.setTimeout(function () {
                if (_this.willOpen) {
                    _this.setState({ targetElement: target, open: true });
                }
            }, this.props.openDelay);
        }
    };
    Tooltip.prototype.isVisible = function (element) {
        return !this.props.filter || this.props.filter(element);
    };
    /**
     * @hidden
     */
    Tooltip.propTypes = {
        anchorElement: PropTypes.oneOf(['pointer', 'target']),
        content: PropTypes.func,
        filter: PropTypes.func,
        openDelay: PropTypes.number,
        position: PropTypes.oneOf(['right', 'left', 'top', 'bottom', 'auto'])
    };
    Tooltip.defaultProps = {
        anchorElement: 'pointer',
        openDelay: 400,
        position: 'auto',
        showCallout: true,
        parentTitle: false
    };
    return Tooltip;
}(React.PureComponent));
export { Tooltip };
//# sourceMappingURL=Tooltip.js.map