{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { StepperContext } from './context/StepperContext';\nimport { classNames, focusFirstFocusableChild, useRtl, dispatchEvent, Keys } from '@progress/kendo-react-common';\nimport { Step } from './Step';\nimport { ProgressBar } from '@progress/kendo-react-progressbars';\nimport { DEFAULT_ANIMATION_DURATION, NO_ANIMATION } from './contants';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { packageMetadata } from '../package-metadata';\n/**\n * Represents the [KendoReact Stepper component]({% slug overview_stepper %}).\n *\n * @example\n * ```jsx\n * const steps = [\n *    { label: 'Step 1' },\n *    { label: 'Step 2' },\n *    { label: 'Step 3', optional: true }\n * ];\n *\n * const App = () => {\n *   return (\n *       <Stepper items={steps} value={1} />\n *   );\n * };\n *    ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\n\nexport var Stepper = React.forwardRef(function (props, target) {\n  validatePackage(packageMetadata);\n  var animationDuration = props.animationDuration,\n      children = props.children,\n      className = props.className,\n      disabled = props.disabled,\n      errorIcon = props.errorIcon,\n      item = props.item,\n      items = props.items,\n      linear = props.linear,\n      mode = props.mode,\n      orientation = props.orientation,\n      style = props.style,\n      successIcon = props.successIcon,\n      onChange = props.onChange,\n      onFocus = props.onFocus;\n  var elementRef = React.useRef(null);\n  var focusElement = React.useCallback(function () {\n    if (elementRef.current) {\n      focusFirstFocusableChild(elementRef.current);\n    }\n  }, []);\n  var getImperativeHandle = React.useCallback(function () {\n    return {\n      element: elementRef.current,\n      focus: focusElement\n    };\n  }, [focusElement]);\n  React.useImperativeHandle(target, getImperativeHandle);\n  var value = props.value || defaultProps.value;\n\n  var _a = React.useState(value),\n      focusedIdx = _a[0],\n      setFocusedIdx = _a[1];\n\n  var numOfSteps = items ? items.length : 0;\n  var isVertical = orientation === 'vertical';\n  var dir = useRtl(elementRef, props.dir);\n  var animation = typeof animationDuration === 'number' ? animationDuration : animationDuration !== false ? DEFAULT_ANIMATION_DURATION : NO_ANIMATION;\n  var dispatchChangeEvent = React.useCallback(function (event, val) {\n    var prevIdx = val === value - 1;\n    var currIdx = val === value;\n    var nextIdx = val === value + 1;\n    var allowClick = !linear || prevIdx || currIdx || nextIdx;\n\n    if (value !== val && onChange && !disabled && allowClick) {\n      dispatchEvent(onChange, event, getImperativeHandle(), {\n        value: val\n      });\n      setFocusedIdx(val);\n    }\n  }, [value, linear, onChange, disabled, setFocusedIdx]);\n  var handleChange = React.useCallback(function (event) {\n    var currentValue = event.value;\n    var syntethicEvent = event.syntheticEvent;\n    dispatchChangeEvent(syntethicEvent, currentValue);\n  }, [dispatchChangeEvent]);\n  var handleFocus = React.useCallback(function (event) {\n    if (onFocus && !disabled) {\n      dispatchEvent(onFocus, event.syntheticEvent, getImperativeHandle(), undefined);\n    }\n  }, [onFocus, disabled]);\n  var handleEnter = React.useCallback(function (event) {\n    dispatchChangeEvent(event, focusedIdx);\n  }, [dispatchChangeEvent, focusedIdx]);\n  var handleKeyDown = React.useCallback(function (event) {\n    var isRtl = dir === 'rtl';\n    var currIndex = focusedIdx;\n    var maxNavIndex = items.length - 1;\n\n    switch (event.keyCode) {\n      case Keys.left:\n        event.preventDefault();\n\n        if (!isRtl && currIndex > 0) {\n          setFocusedIdx(currIndex - 1);\n        }\n\n        if (isRtl && currIndex < maxNavIndex) {\n          setFocusedIdx(currIndex + 1);\n        }\n\n        break;\n\n      case Keys.right:\n        event.preventDefault();\n\n        if (!isRtl && currIndex < maxNavIndex) {\n          setFocusedIdx(currIndex + 1);\n        }\n\n        if (isRtl && currIndex > 0) {\n          setFocusedIdx(currIndex - 1);\n        }\n\n        break;\n\n      case Keys.up:\n        event.preventDefault();\n\n        if (!isRtl && currIndex > 0) {\n          setFocusedIdx(currIndex - 1);\n        }\n\n        if (isRtl && currIndex > 0) {\n          setFocusedIdx(currIndex - 1);\n        }\n\n        break;\n\n      case Keys.down:\n        event.preventDefault();\n\n        if (!isRtl && currIndex < maxNavIndex) {\n          setFocusedIdx(currIndex + 1);\n        }\n\n        if (isRtl && currIndex < maxNavIndex) {\n          setFocusedIdx(currIndex + 1);\n        }\n\n        break;\n\n      case Keys.home:\n        event.preventDefault();\n        setFocusedIdx(0);\n        break;\n\n      case Keys.end:\n        event.preventDefault();\n        setFocusedIdx(maxNavIndex);\n        break;\n\n      case Keys.space:\n      case Keys.enter:\n        event.preventDefault();\n\n        if (!items[currIndex].disabled) {\n          handleEnter(event);\n        }\n\n        break;\n\n      default:\n    }\n  }, [items, setFocusedIdx, focusedIdx, dir, handleEnter]);\n  var stepperClasses = React.useMemo(function () {\n    return classNames('k-stepper', {\n      'k-stepper-linear': linear\n    }, className);\n  }, [linear, className]);\n  var stepperStyles = React.useMemo(function () {\n    return __assign({\n      display: 'grid',\n      gridTemplateColumns: !isVertical ? 'repeat(' + numOfSteps * 2 + ', 1fr)' : undefined,\n      gridTemplateRows: isVertical ? 'repeat(' + numOfSteps * 4 + ', 1fr)' : undefined\n    }, style);\n  }, [isVertical, numOfSteps, style]);\n  var listClasses = React.useMemo(function () {\n    return classNames('k-step-list', {\n      'k-step-list-horizontal': !isVertical,\n      'k-step-list-vertical': isVertical\n    });\n  }, [isVertical]);\n  var listStyles = React.useMemo(function () {\n    return {\n      gridColumnStart: !isVertical ? 1 : undefined,\n      gridColumnEnd: !isVertical ? -1 : undefined,\n      gridRowStart: isVertical ? 1 : undefined,\n      gridRowEnd: isVertical ? -1 : undefined\n    };\n  }, [isVertical]);\n  var progressbarStyles = React.useMemo(function () {\n    return {\n      gridColumnStart: !isVertical ? 2 : undefined,\n      gridColumnEnd: !isVertical ? numOfSteps * 2 : undefined,\n      gridRowStart: isVertical ? 2 : undefined,\n      gridRowEnd: isVertical ? numOfSteps * 4 - 2 : undefined\n    };\n  }, [isVertical, numOfSteps]);\n  var steps = items && items.map(function (element, index) {\n    var stepProps = __assign({\n      index: index,\n      disabled: disabled || element.disabled,\n      focused: index === focusedIdx,\n      current: index === value\n    }, element);\n\n    var ItemComp = item || Step;\n    return React.createElement(ItemComp, __assign({\n      key: index\n    }, stepProps));\n  });\n  return React.createElement(StepperContext.Provider, {\n    value: {\n      animationDuration: animationDuration,\n      isVertical: isVertical,\n      item: item,\n      linear: linear,\n      mode: mode,\n      numOfSteps: numOfSteps,\n      value: value,\n      successIcon: successIcon,\n      errorIcon: errorIcon,\n      onChange: handleChange,\n      onFocus: handleFocus\n    }\n  }, React.createElement(\"nav\", {\n    className: stepperClasses,\n    style: stepperStyles,\n    dir: dir,\n    onKeyDown: handleKeyDown\n  }, React.createElement(\"ol\", {\n    className: listClasses,\n    style: listStyles\n  }, steps ? steps : children), React.createElement(ProgressBar, {\n    style: progressbarStyles,\n    animation: {\n      duration: animation\n    },\n    \"aria-hidden\": true,\n    max: numOfSteps - 1,\n    labelVisible: false,\n    orientation: orientation,\n    reverse: orientation === 'vertical',\n    value: value,\n    disabled: disabled,\n    tabIndex: -1\n  })));\n});\nStepper.propTypes = {\n  animationDuration: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\n  className: PropTypes.string,\n  dir: PropTypes.string,\n  disabled: PropTypes.bool,\n  item: PropTypes.any,\n  items: PropTypes.arrayOf(PropTypes.any),\n  linear: PropTypes.bool,\n  mode: PropTypes.oneOf(['steps', 'labels']),\n  orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n  style: PropTypes.object,\n  value: PropTypes.number.isRequired,\n  onChange: PropTypes.func,\n  onFocus: PropTypes.func\n};\nvar defaultProps = {\n  value: 0\n};\nStepper.defaultProps = defaultProps;\nStepper.displayName = 'KendoStepper';","map":null,"metadata":{},"sourceType":"module"}