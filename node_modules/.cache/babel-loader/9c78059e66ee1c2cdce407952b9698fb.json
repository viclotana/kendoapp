{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport * as React from 'react';\nimport { SplitterPane } from './SplitterPane';\nimport { SplitterBar } from './SplitterBar';\nimport { classNames } from '@progress/kendo-react-common';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { packageMetadata } from '../package-metadata';\n/**\n * @hidden\n */\n\nvar PANE_DEFAULTS = {\n  collapsible: false,\n  collapsed: false,\n  resizable: true,\n  scrollable: true\n};\n/**\n * @hidden\n */\n\nvar DOUBLE_CLICK_WAIT_TIME = 150;\n/**\n * Represents the [KendoReact Splitter component]({% slug overview_splitter %}).\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *    render() {\n *        return (\n *            <div>\n *                <Splitter\n *                    style={{height: 400}}\n *                    orientation={'vertical'}\n *                >\n *                    <div>Pane 1</div>\n *                    <div>Pane 2</div>\n *                    <div>Pane 3</div>\n *                </Splitter>\n *            </div>\n *        );\n *    }\n * }\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\n\nvar Splitter =\n/** @class */\nfunction (_super) {\n  __extends(Splitter, _super);\n  /**\n   * @hidden\n   */\n\n\n  function Splitter(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.validatePanes = function (panesOptions) {\n      var withoutSize = panesOptions.filter(function (pane) {\n        return pane.size === undefined;\n      });\n\n      if (!withoutSize.length) {\n        throw new Error('The Splitter should have at least one pane without a set size.');\n      }\n    };\n\n    _this.mapPaneOptions = function (panes, panesContent) {\n      var orientation = _this.orientation;\n      var _a = _this.state,\n          dragIndex = _a.dragIndex,\n          isDragging = _a.isDragging;\n      var paneOptions = [];\n\n      for (var index = 0; index < panesContent.length; index++) {\n        var containsSplitter = false;\n        var paneContent = panesContent[index];\n\n        if (React.isValidElement(paneContent)) {\n          containsSplitter = paneContent.type.displayName === 'Splitter';\n        }\n\n        var overlay = false;\n\n        if (isDragging && dragIndex !== undefined) {\n          overlay = dragIndex === index || dragIndex + 1 === index;\n        }\n\n        paneOptions.push(__assign({}, PANE_DEFAULTS, {\n          orientation: orientation,\n          containsSplitter: containsSplitter,\n          overlay: overlay\n        }, (panes || [])[index]));\n      }\n\n      return paneOptions;\n    };\n\n    _this.mapSplitterPanes = function (panes, panesContent) {\n      return panes.map(function (pane, index) {\n        var splitterBar;\n        var paneKey = index * 2;\n        var barKey = paneKey + 1;\n\n        if (index + 1 < panes.length) {\n          var next = panes[index + 1];\n          splitterBar = React.createElement(SplitterBar, {\n            key: barKey,\n            index: index,\n            orientation: pane.orientation,\n            prev: pane,\n            next: next,\n            onDrag: _this.onBarDragResize,\n            onToggle: _this.onBarToggle,\n            onKeyboardResize: _this.onBarKeyboardResize\n          });\n        }\n\n        var splitterPane = React.createElement(SplitterPane, __assign({\n          key: paneKey\n        }, pane), panesContent[index]);\n        return [splitterPane, splitterBar];\n      });\n    };\n\n    _this.onBarToggle = function (index, event) {\n      var panesOptions = _this.panesOptions(_this.panesContent);\n\n      var updatedState = panesOptions.map(function (pane, idx) {\n        var paneProps = _this.getPaneProps(pane);\n\n        if (idx === index) {\n          return __assign({}, paneProps, {\n            collapsed: !pane.collapsed\n          });\n        } else {\n          return __assign({}, paneProps);\n        }\n      });\n\n      if (_this.props.onChange) {\n        _this.props.onChange({\n          newState: updatedState,\n          isLast: true,\n          nativeEvent: event\n        });\n      }\n    };\n\n    _this.onBarDragResize = function (event, barElement, index, isFirst, isLast) {\n      var time = new Date().getTime();\n      var pageX = event.pageX,\n          pageY = event.pageY;\n\n      var _a = _this.surroudingPanes(barElement),\n          prevElement = _a.prevElement,\n          nextElement = _a.nextElement;\n\n      if (!prevElement || !nextElement) {\n        return;\n      }\n\n      if (isFirst) {\n        _this.setState({\n          isDragging: true,\n          dragIndex: index,\n          startTime: time,\n          originalX: pageX,\n          originalY: pageY,\n          originalPrevSize: _this.elementSize(prevElement),\n          originalNextSize: _this.elementSize(nextElement)\n        });\n\n        return;\n      }\n\n      var _b = _this.state,\n          originalPrevSize = _b.originalPrevSize,\n          originalNextSize = _b.originalNextSize,\n          startTime = _b.startTime,\n          originalX = _b.originalX,\n          originalY = _b.originalY;\n\n      if (!isFirst && time - startTime < DOUBLE_CLICK_WAIT_TIME) {\n        if (isLast) {\n          _this.resetDragState();\n        }\n\n        return;\n      }\n\n      var delta;\n\n      if (_this.orientation === 'vertical') {\n        delta = pageY - originalY;\n      } else if (_this.isRtl) {\n        delta = originalX - pageX;\n      } else {\n        delta = pageX - originalX;\n      }\n\n      _this.resize(index, index + 1, originalPrevSize, originalNextSize, delta, isLast, event);\n\n      if (isLast) {\n        _this.resetDragState();\n      }\n    };\n\n    _this.onBarKeyboardResize = function (barElement, index, delta, event) {\n      var _a = _this.surroudingPanes(barElement),\n          prevElement = _a.prevElement,\n          nextElement = _a.nextElement;\n\n      var originalPrevSize = _this.elementSize(prevElement);\n\n      var originalNextSize = _this.elementSize(nextElement);\n\n      _this.resize(index, index + 1, originalPrevSize, originalNextSize, delta, true, event);\n    };\n\n    _this.containerSize = function () {\n      if (!_this._container) {\n        return 0;\n      }\n\n      return _this.elementSize(_this._container, true);\n    };\n\n    _this.panesOptions = function (panesContent) {\n      return _this.mapPaneOptions(_this.panes, panesContent);\n    };\n\n    _this.elementSize = function (el, isContainer) {\n      var sizeType = isContainer ? 'client' : 'offset';\n\n      if (_this.orientation === 'vertical') {\n        return el[sizeType + \"Height\"];\n      } else {\n        return el[sizeType + \"Width\"];\n      }\n    };\n\n    _this.clamp = function (min, max, v) {\n      return Math.min(max, Math.max(min, v));\n    };\n\n    _this.fixedSize = function (size) {\n      return size && size.length > 0;\n    };\n\n    validatePackage(packageMetadata);\n    _this.state = {\n      isDragging: false,\n      dragIndex: undefined,\n      startTime: 0,\n      originalX: 0,\n      originalY: 0,\n      originalPrevSize: 0,\n      originalNextSize: 0,\n      panes: props.defaultPanes || []\n    };\n    return _this;\n  }\n\n  Object.defineProperty(Splitter.prototype, \"isControlledState\", {\n    get: function () {\n      return this.props.panes !== undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Splitter.prototype, \"panes\", {\n    get: function () {\n      return this.panesDuringOnChange !== undefined ? this.panesDuringOnChange : this.isControlledState ? this.props.panes : this.state.panes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Splitter.prototype, \"orientation\", {\n    get: function () {\n      return this.props.orientation || 'horizontal';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Splitter.prototype, \"isRtl\", {\n    get: function () {\n      return this._container && getComputedStyle(this._container).direction === 'rtl' || false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Splitter.prototype, \"panesContent\", {\n    get: function () {\n      return React.Children.toArray(this.props.children).filter(function (c) {\n        return c;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @hidden\n   */\n\n  Splitter.prototype.render = function () {\n    var _this = this;\n\n    var panesContent = this.panesContent;\n    var panesOptions = this.panesOptions(panesContent);\n    var className = classNames('k-widget', 'k-splitter', 'k-splitter-flex', \"k-splitter-\" + this.orientation, this.props.className);\n    this.validatePanes(panesOptions);\n    return React.createElement(\"div\", {\n      style: this.props.style,\n      ref: function (ref) {\n        return _this._container = ref;\n      },\n      className: className\n    }, this.mapSplitterPanes(panesOptions, panesContent));\n  };\n\n  Splitter.prototype.surroudingPanes = function (barElement) {\n    return {\n      prevElement: barElement.previousElementSibling,\n      nextElement: barElement.nextElementSibling\n    };\n  };\n\n  Splitter.prototype.isPercent = function (size) {\n    return /%$/.test(size);\n  };\n\n  Splitter.prototype.toPixels = function (size, splitterSize) {\n    var result = parseInt(size, 10);\n\n    if (this.isPercent(size)) {\n      result = splitterSize * result / 100;\n    }\n\n    return result;\n  };\n\n  Splitter.prototype.resetDragState = function () {\n    this.setState({\n      isDragging: false,\n      dragIndex: undefined,\n      startTime: 0,\n      originalX: 0,\n      originalY: 0,\n      originalPrevSize: 0,\n      originalNextSize: 0\n    });\n  };\n\n  Splitter.prototype.resize = function (prevIndex, nextIndex, originalPrevSize, originalNextSize, delta, isLast, event) {\n    var _this = this;\n\n    var panesOptions = this.panesOptions(this.panesContent);\n    var prevOptions = panesOptions[prevIndex];\n    var nextOptions = panesOptions[nextIndex];\n    var total = originalPrevSize + originalNextSize;\n    var splitterSize = this.containerSize();\n\n    var px = function (s) {\n      return _this.toPixels(s, splitterSize);\n    };\n\n    var prevDragState = {\n      index: prevIndex,\n      initialSize: originalPrevSize,\n      min: px(prevOptions.min) || total - px(nextOptions.max) || 0,\n      max: px(prevOptions.max) || total - px(nextOptions.min) || total\n    };\n    var nextDragState = {\n      index: nextIndex,\n      initialSize: originalNextSize,\n      min: px(nextOptions.min) || total - px(prevOptions.max) || 0,\n      max: px(nextOptions.max) || total - px(prevOptions.min) || total\n    };\n\n    var resize = function (paneState, change) {\n      var pane = panesOptions[paneState.index];\n\n      var newSize = _this.clamp(paneState.min, paneState.max, paneState.initialSize + change);\n\n      if (_this.isPercent(pane.size || '')) {\n        return 100 * newSize / splitterSize + '%';\n      } else {\n        return newSize + 'px';\n      }\n    };\n\n    var prevSize;\n    var nextSize;\n\n    if (this.fixedSize(prevOptions.size) && this.fixedSize(nextOptions.size)) {\n      prevSize = resize(prevDragState, delta);\n      nextSize = resize(nextDragState, -delta);\n    } else if (nextOptions.collapsible || this.fixedSize(nextOptions.size)) {\n      nextSize = resize(nextDragState, -delta);\n    } else {\n      prevSize = resize(prevDragState, delta);\n    }\n\n    var updatedState = panesOptions.map(function (pane, idx) {\n      var paneProps = _this.getPaneProps(pane);\n\n      if (idx === prevIndex) {\n        return __assign({}, paneProps, {\n          size: prevSize\n        });\n      } else if (idx === nextIndex) {\n        return __assign({}, paneProps, {\n          size: nextSize\n        });\n      } else {\n        return __assign({}, paneProps);\n      }\n    });\n    this.panesDuringOnChange = updatedState;\n\n    if (!this.isControlledState) {\n      this.setState({\n        panes: updatedState\n      });\n    }\n\n    if (this.props.onChange) {\n      this.props.onChange({\n        newState: updatedState,\n        isLast: isLast,\n        nativeEvent: event\n      });\n    }\n\n    this.panesDuringOnChange = undefined;\n  };\n\n  Splitter.prototype.getPaneProps = function (pane) {\n    var orientation = pane.orientation,\n        overlay = pane.overlay,\n        containsSplitter = pane.containsSplitter,\n        others = __rest(pane, [\"orientation\", \"overlay\", \"containsSplitter\"]);\n\n    return others;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Splitter.displayName = 'Splitter';\n  return Splitter;\n}(React.Component);\n\nexport { Splitter };","map":null,"metadata":{},"sourceType":"module"}