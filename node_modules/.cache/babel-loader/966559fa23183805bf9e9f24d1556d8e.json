{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport * as PropTypes from 'prop-types';\nimport { slide } from './animation';\nimport { classNames, canUseDOM } from '@progress/kendo-react-common';\nimport { CollisionType, AlignPoint, throttle, FRAME_DURATION } from './util';\nimport { AlignService } from './services/alignService';\nimport { DOMService } from './services/domService';\nimport { PositionService } from './services/positionService';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { packageMetadata } from './package-metadata';\n\nfunction isEquivalent(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (!!a !== !!b) {\n    return false;\n  }\n\n  var aProps = Object.getOwnPropertyNames(a);\n  var bProps = Object.getOwnPropertyNames(b);\n\n  if (aProps.length !== bProps.length) {\n    return false;\n  }\n\n  for (var i = 0; i < aProps.length; i++) {\n    var propName = aProps[i];\n\n    if (a[propName] !== b[propName]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar DEFAULT_OFFSET = {\n  left: -1000,\n  top: 0\n};\nvar Status;\n\n(function (Status) {\n  Status[\"hiding\"] = \"hiding\";\n  Status[\"hidden\"] = \"hidden\";\n  Status[\"showing\"] = \"showing\";\n  Status[\"shown\"] = \"shown\";\n  Status[\"reposition\"] = \"reposition\";\n})(Status || (Status = {}));\n\nvar ANIMATION_CONTAINER = 'k-animation-container';\nvar ANIMATION_CONTAINER_SHOWN = 'k-animation-container-shown';\nvar ANIMATION_CONTAINER_RELATIVE = 'k-animation-container-relative';\nvar ANIMATION_CONTAINER_CHILD = 'k-child-animation-container';\nvar K_POPUP = 'k-popup';\n/**\n * @hidden\n */\n\nvar Popup =\n/** @class */\nfunction (_super) {\n  __extends(Popup, _super);\n\n  function Popup(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * @hidden\n     */\n\n\n    _this.state = {\n      current: Status.hidden,\n      previous: Status.hidden,\n      props: {}\n    };\n    _this._popup = null;\n\n    _this.show = function (popup) {\n      _this.setPosition(popup);\n\n      _this.animate(popup.firstChild, 'enter', _this.onOpened);\n\n      _this.setState({\n        current: Status.shown,\n        previous: _this.state.current\n      });\n    };\n\n    _this.setPosition = function (popup) {\n      var _a = _this.props,\n          anchorAlign = _a.anchorAlign,\n          popupAlign = _a.popupAlign,\n          collision = _a.collision,\n          offset = _a.offset,\n          anchor = _a.anchor;\n      var popupContent = popup.firstElementChild;\n\n      var _b = getComputedStyle(popupContent),\n          contentWidth = _b.width,\n          contentHeight = _b.height; // The absolute position prevents appearing of a scrollbar which could move the anchor element and breaks the positioning.\n\n\n      popupContent.style.position = 'absolute'; // Width and height are required since absolute position breaks the element sizing.\n\n      popupContent.style.width = contentWidth;\n      popupContent.style.height = contentHeight;\n\n      var alignedOffset = _this._alignService.alignElement({\n        anchor: anchor,\n        element: popupContent,\n        elementAlign: popupAlign,\n        anchorAlign: anchorAlign,\n        offset: offset\n      });\n\n      var position = _this._positionService.positionElement({\n        anchor: anchor,\n        anchorAlign: anchorAlign,\n        collisions: collision,\n        element: popupContent,\n        currentLocation: alignedOffset,\n        elementAlign: popupAlign\n      });\n\n      if (position.offset) {\n        popup.style.top = position.offset.top + 'px';\n        popup.style.left = position.offset.left + 'px';\n        popupContent.style.position = '';\n        popupContent.style.width = '';\n        popupContent.style.height = '';\n      }\n\n      _this._flipped = position.flipped;\n    };\n\n    _this.onOpened = function () {\n      var element = _this._popup;\n\n      if (!element) {\n        return;\n      }\n\n      if (_this.props.show) {\n        element.classList.add(ANIMATION_CONTAINER_SHOWN);\n      }\n\n      _this.attachRepositionHandlers(element);\n\n      if (_this.props.onOpen) {\n        _this.props.onOpen.call(undefined, {\n          target: _this\n        });\n      }\n    };\n\n    _this.animate = function (element, type, callback) {\n      slide(element, _this._flipped ? 'up' : 'down', _this.animationDuration[type], type, callback);\n    };\n\n    _this.onClosing = function (popup) {\n      if (!_this.props.show) {\n        popup.classList.remove(ANIMATION_CONTAINER_SHOWN);\n      }\n\n      _this.detachRepositionHandlers();\n    };\n\n    _this.onClosed = function () {\n      if (_this.state.current === Status.hiding && _this.state.previous === Status.shown) {\n        _this.setState({\n          current: Status.hidden,\n          previous: _this.state.current\n        });\n      }\n\n      if (_this.props.onClose) {\n        _this.props.onClose.call(undefined, {\n          target: _this\n        });\n      }\n    };\n\n    validatePackage(packageMetadata);\n    _this._domService = new DOMService();\n    _this._alignService = new AlignService(_this._domService);\n    _this._positionService = new PositionService(_this._domService);\n    _this.reposition = throttle(_this.reposition.bind(_this), FRAME_DURATION);\n    return _this;\n  }\n  /**\n   * @hidden\n   */\n\n\n  Popup.getDerivedStateFromProps = function (props, state) {\n    var show = props.show,\n        anchor = props.anchor,\n        anchorAlign = props.anchorAlign,\n        appendTo = props.appendTo,\n        collision = props.collision,\n        popupAlign = props.popupAlign,\n        className = props.className,\n        popupClass = props.popupClass,\n        style = props.style,\n        offset = props.offset,\n        contentKey = props.contentKey;\n\n    var nextState = __assign({}, state, {\n      props: {\n        show: show,\n        anchor: anchor,\n        anchorAlign: anchorAlign,\n        appendTo: appendTo,\n        collision: collision,\n        popupAlign: popupAlign,\n        className: className,\n        popupClass: popupClass,\n        style: style,\n        offset: offset,\n        contentKey: contentKey\n      }\n    });\n\n    if (props.show) {\n      if (state.current === Status.hidden || state.current === Status.hiding) {\n        return __assign({}, nextState, {\n          current: Status.showing,\n          previous: state.current\n        });\n      } else if (state.current === Status.showing) {\n        return __assign({}, nextState, {\n          current: Status.shown,\n          previous: state.current\n        });\n      }\n\n      if (state.current === Status.shown && (!isEquivalent(offset, state.props.offset) || !isEquivalent(anchorAlign, state.props.anchorAlign) || !isEquivalent(appendTo, state.props.appendTo) || !isEquivalent(collision, state.props.collision) || !isEquivalent(popupAlign, state.props.popupAlign) || !isEquivalent(style, state.props.style) || anchor !== state.props.anchor || popupClass !== state.props.popupClass || className !== state.props.className)) {\n        return __assign({}, nextState, {\n          current: Status.reposition,\n          previous: state.current\n        });\n      }\n    } else {\n      if (state.current === Status.shown || state.current === Status.showing) {\n        return __assign({}, nextState, {\n          current: Status.hiding,\n          previous: state.current\n        });\n      } else if (state.current === Status.hiding) {\n        return __assign({}, nextState, {\n          current: Status.hidden,\n          previous: state.current\n        });\n      }\n    }\n\n    return nextState;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Popup.prototype.componentDidUpdate = function (prevProps) {\n    if (this.state.current === Status.showing && this._popup) {\n      this.show(this._popup);\n    } else if (this.state.current === Status.hiding && this._popup) {\n      this.onClosing(this._popup);\n      this.animate(this._popup.firstChild, 'exit', this.onClosed);\n    } else if (this.state.current === Status.reposition && this.state.previous === Status.shown) {\n      this.setState({\n        current: Status.shown,\n        previous: this.state.current\n      });\n    } else if (this.state.current === Status.shown && prevProps.contentKey !== this.props.contentKey && this._popup) {\n      this.setPosition(this._popup);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Popup.prototype.componentDidMount = function () {\n    if (this.state.current === Status.showing && this._popup) {\n      this.show(this._popup);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Popup.prototype.componentWillUnmount = function () {\n    this.detachRepositionHandlers();\n  };\n  /**\n   * @hidden\n   */\n\n\n  Popup.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        children = _a.children,\n        className = _a.className,\n        popupClass = _a.popupClass,\n        show = _a.show,\n        id = _a.id,\n        _b = _a.appendTo,\n        appendTo = _b === void 0 ? canUseDOM ? document.body : undefined : _b;\n\n    if (this.state.current === Status.reposition && this.state.previous === Status.shown && this._popup) {\n      this.setPosition(this._popup);\n    }\n\n    var style = Object.assign({}, {\n      position: 'absolute'\n    }, this.props.style || {});\n    var closing = this.state.current === Status.hiding && this.state.previous === Status.shown;\n\n    if ((show || closing) && appendTo) {\n      var popup = React.createElement(\"div\", {\n        className: classNames(ANIMATION_CONTAINER, ANIMATION_CONTAINER_RELATIVE, className),\n        id: id,\n        ref: function (e) {\n          return _this._popup = e;\n        },\n        style: style\n      }, React.createElement(\"div\", {\n        className: classNames(popupClass, K_POPUP, ANIMATION_CONTAINER_CHILD),\n        style: {\n          transitionDelay: '0ms'\n        }\n      }, children));\n      return ReactDOM.createPortal(popup, appendTo);\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(Popup.prototype, \"animationDuration\", {\n    get: function () {\n      var animate = this.props.animate;\n      var enter = 0;\n      var exit = 0;\n\n      if (animate) {\n        if (animate === true) {\n          enter = exit = 300;\n        } else {\n          enter = animate.openDuration || 0;\n          exit = animate.closeDuration || 0;\n        }\n      }\n\n      return {\n        enter: enter,\n        exit: exit\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Popup.prototype.attachRepositionHandlers = function (element) {\n    var _this = this;\n\n    this.detachRepositionHandlers();\n    this._scrollableParents = this._domService.scrollableParents(this.props.anchor || element);\n\n    this._scrollableParents.map(function (p) {\n      return p.addEventListener('scroll', _this.reposition);\n    });\n\n    window.addEventListener('resize', this.reposition);\n  };\n\n  Popup.prototype.detachRepositionHandlers = function () {\n    var _this = this;\n\n    if (this._scrollableParents) {\n      this._scrollableParents.map(function (p) {\n        return p.removeEventListener('scroll', _this.reposition);\n      });\n\n      this._scrollableParents = undefined;\n    }\n\n    window.removeEventListener('resize', this.reposition);\n  };\n\n  Popup.prototype.reposition = function () {\n    this.setState({\n      current: Status.reposition,\n      previous: this.state.current\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Popup.propTypes = {\n    anchor: function (props) {\n      var anchor = props.anchor;\n\n      if (anchor && typeof anchor.nodeType !== 'number') {\n        return new Error('Invalid prop `anchor` supplied to `Kendo React Popup`. Validation failed.');\n      }\n    },\n    appendTo: function (props) {\n      var element = props.appendTo;\n\n      if (element && typeof element.nodeType !== 'number') {\n        return new Error('Invalid prop `appendTo` supplied to `Kendo React Popup`. Validation failed.');\n      }\n    },\n    className: PropTypes.string,\n    id: PropTypes.string,\n    popupClass: PropTypes.string,\n    collision: PropTypes.shape({\n      horizontal: PropTypes.oneOf([CollisionType.fit, CollisionType.flip]),\n      vertical: PropTypes.oneOf([CollisionType.fit, CollisionType.flip])\n    }),\n    anchorAlign: PropTypes.shape({\n      horizontal: PropTypes.oneOf([AlignPoint.left, AlignPoint.center, AlignPoint.right]),\n      vertical: PropTypes.oneOf([AlignPoint.top, AlignPoint.center, AlignPoint.bottom])\n    }),\n    popupAlign: PropTypes.shape({\n      horizontal: PropTypes.oneOf([AlignPoint.left, AlignPoint.center, AlignPoint.right]),\n      vertical: PropTypes.oneOf([AlignPoint.top, AlignPoint.center, AlignPoint.bottom])\n    }),\n    offset: PropTypes.shape({\n      left: PropTypes.number,\n      top: PropTypes.number\n    }),\n    children: PropTypes.oneOfType([PropTypes.element, PropTypes.node]),\n    show: PropTypes.bool,\n    animate: PropTypes.oneOfType([PropTypes.bool, PropTypes.shape({\n      openDuration: PropTypes.number,\n      closeDuration: PropTypes.number\n    })])\n  };\n  /**\n   * @hidden\n   */\n\n  Popup.defaultProps = {\n    collision: {\n      horizontal: CollisionType.fit,\n      vertical: CollisionType.flip\n    },\n    anchorAlign: {\n      horizontal: AlignPoint.left,\n      vertical: AlignPoint.bottom\n    },\n    popupAlign: {\n      horizontal: AlignPoint.left,\n      vertical: AlignPoint.top\n    },\n    offset: DEFAULT_OFFSET,\n    animate: true,\n    // appendTo: document.body,\n    show: false\n  };\n  return Popup;\n}(React.Component);\n\nexport { Popup };","map":null,"metadata":{},"sourceType":"module"}