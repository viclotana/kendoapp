{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { classNames, Keys, guid, dispatchEvent } from '@progress/kendo-react-common';\nimport { getDirectParentId, isIdEmptyOrZeroLevel, EMPTY_ID, ZERO_LEVEL_ZERO_ITEM_ID, getRootParentId, getItemById } from '../utils/itemsIdsUtils';\nimport { prepareInputItemsForInternalWork } from '../utils/prepareInputItemsForInternalWork';\nimport { getNewItemIdUponKeyboardNavigation } from '../utils/getNewItemIdUponKeyboardNavigation';\nimport { getHoverOpenDelay, getHoverCloseDelay } from '../utils/hoverDelay';\nimport { MenuItemInternalsList } from './MenuItemInternalsList';\nimport { DirectionHolder } from '../utils/DirectionHolder';\nimport { MouseOverHandler } from '../utils/MouseOverHandler';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { packageMetadata } from '../../package-metadata';\nvar initialItemsIds = {\n  focusedItemId: EMPTY_ID,\n  hoveredItemId: EMPTY_ID,\n  tabbableItemId: ZERO_LEVEL_ZERO_ITEM_ID\n};\n/**\n * Represents the [KendoReact Menu component]({% slug overview_menu %}).\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *    render() {\n *        return (\n *            <Menu>\n *                <MenuItem text=\"Item1\" />\n *                <MenuItem text=\"Item2\">\n *                    <MenuItem text=\"Item2.1\" />\n *                    <MenuItem text=\"Item2.2\" />\n *                </MenuItem>\n *                <MenuItem text=\"Item3\" />\n *            </Menu>\n *        );\n *    }\n * }\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\n\nvar Menu =\n/** @class */\nfunction (_super) {\n  __extends(Menu, _super);\n\n  function Menu(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.guid = guid();\n    _this.directionHolder = new DirectionHolder();\n    /**\n     * Resets the selection and opening of Menu items.\n     */\n\n    _this.reset = function () {\n      _this.clearItemHoverAndLeaveRequestsIfApplicable();\n\n      _this.setState(initialItemsIds);\n    };\n\n    _this.onKeyDown = function (event) {\n      // The focusedItemId may be empty when contentRender is used.\n      // For example, content with input.\n      if (_this.state.focusedItemId !== EMPTY_ID) {\n        var currentItem = getItemById(_this.state.focusedItemId, _this.items);\n        var newItemId = getNewItemIdUponKeyboardNavigation(_this.items, currentItem.id, event.keyCode, event.key, _this.props.vertical, _this.directionHolder.getIsDirectionRightToLeft());\n\n        if (currentItem.id !== newItemId) {\n          event.preventDefault();\n\n          _this.setFocusedItemId(newItemId);\n        }\n\n        if ((event.keyCode === Keys.enter || event.keyCode === Keys.space) && !currentItem.disabled) {\n          _this.mouseOverHandler.handleItemSelectedViaKeyboard();\n\n          _this.dispatchSelectEventIfWired(event, currentItem.id);\n\n          if (!event.isDefaultPrevented() && currentItem.items.length === 0 && currentItem.url) {\n            window.location.assign(currentItem.url);\n          }\n        }\n      }\n    };\n\n    _this.onItemMouseOver = function (itemId) {\n      if (_this.mouseOverHandler.IsMouseOverEnabled) {\n        // The `over` event can get fired even without actually leaving the item.\n        // For example, move the mouse little by little over the item content.\n        _this.clearItemHoverAndLeaveRequestsIfApplicable();\n\n        _this.itemHoverRequest = window.setTimeout(function () {\n          _this.setHoveredItemId(itemId);\n\n          _this.itemHoverRequest = null;\n        }, getHoverOpenDelay(_this.props));\n      }\n    };\n\n    _this.onItemMouseLeave = function (itemId) {\n      if (_this.mouseOverHandler.IsMouseOverEnabled && _this.isItemWithDefaultClose(itemId)) {\n        // Both the `leave` and `hover` requests are cleared\n        // to be defensive and consistent with the `over` handler.\n        _this.clearItemHoverAndLeaveRequestsIfApplicable();\n\n        _this.itemLeaveRequest = window.setTimeout(function () {\n          _this.setHoveredItemId(EMPTY_ID);\n\n          _this.itemLeaveRequest = null;\n        }, getHoverCloseDelay(_this.props));\n      }\n    };\n\n    _this.onItemMouseDown = function () {\n      _this.mouseOverHandler.handleItemMouseDown();\n    };\n\n    _this.onItemFocus = function (itemId) {\n      _this.setFocusedItemId(itemId);\n\n      _this.mouseOverHandler.handleItemFocus();\n    };\n\n    _this.onItemClick = function (event, itemId) {\n      var item = getItemById(itemId, _this.items);\n\n      if (!item.disabled) {\n        _this.setFocusedItemId(itemId);\n\n        _this.mouseOverHandler.handleItemClick(itemId, _this.isItemWithDefaultClose(itemId));\n\n        _this.dispatchSelectEventIfWired(event, itemId);\n\n        if (!event.isDefaultPrevented() && item.url) {\n          window.location.assign(item.url);\n        }\n      }\n    };\n\n    _this.onItemBlur = function (itemId) {\n      if (_this.isItemWithDefaultClose(itemId)) {\n        _this.setFocusedItemId(EMPTY_ID);\n      }\n    };\n\n    _this.getInputItem = function (itemId) {\n      return getItemById(itemId, _this.inputItems);\n    };\n\n    validatePackage(packageMetadata);\n    _this.mouseOverHandler = new MouseOverHandler(_this.props.openOnClick, _this.reset, _this.onItemMouseOver);\n    _this.state = Object.assign({}, initialItemsIds, {\n      isFirstRender: true\n    });\n    return _this;\n  }\n  /**\n   * @hidden\n   */\n\n\n  Menu.prototype.render = function () {\n    var _this = this;\n\n    this.prepareItems();\n\n    if (!this.state.isFirstRender) {\n      this.directionHolder.setIsDirectionRightToLeft(this.checkIsDirectionRightToLeft());\n    }\n\n    var lastItemIdToBeOpened = this.state.hoveredItemId ? this.state.hoveredItemId : this.state.focusedItemId ? getDirectParentId(this.state.focusedItemId) : EMPTY_ID;\n    return React.createElement(\"div\", {\n      onKeyDown: this.onKeyDown,\n      style: this.props.style,\n      className: this.getMenuWrapperClassName(),\n      ref: function (el) {\n        return _this.menuWrapperEl = el;\n      }\n    }, React.createElement(MenuItemInternalsList, {\n      className: this.getMenuClassName(),\n      \"aria-orientation\": this.props.vertical ? 'vertical' : undefined,\n      items: this.items,\n      isMenuVertical: this.props.vertical,\n      isDirectionRightToLeft: this.directionHolder.getIsDirectionRightToLeft(),\n      focusedItemId: this.state.focusedItemId,\n      lastItemIdToBeOpened: lastItemIdToBeOpened,\n      tabbableItemId: this.state.tabbableItemId,\n      itemRender: this.props.itemRender,\n      linkRender: this.props.linkRender,\n      menuGuid: this.guid,\n      onMouseLeave: this.onItemMouseLeave,\n      onMouseOver: this.onItemMouseOver,\n      onMouseDown: this.onItemMouseDown,\n      onFocus: this.onItemFocus,\n      onClick: this.onItemClick,\n      onBlur: this.onItemBlur,\n      onOriginalItemNeeded: this.getInputItem\n    }));\n  };\n  /**\n   * @hidden\n   */\n\n\n  Menu.prototype.componentDidMount = function () {\n    this.setState({\n      isFirstRender: false\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Menu.prototype.componentDidUpdate = function (prevProps) {\n    // Reset the Menu upon big UI changes\n    // to avoid misleading the user and to\n    // keep the component consistent.\n    if (Boolean(prevProps.vertical) !== Boolean(this.props.vertical) || this.directionHolder.hasDirectionChanged()) {\n      this.reset();\n    }\n\n    this.mouseOverHandler.OpenOnClick = this.props.openOnClick;\n  };\n  /**\n   * @hidden\n   */\n\n\n  Menu.prototype.componentWillUnmount = function () {\n    this.clearItemHoverAndLeaveRequestsIfApplicable();\n  };\n\n  Menu.prototype.setFocusedItemId = function (focusedItemId) {\n    this.setState(function (prevState) {\n      var tabbableItemId = focusedItemId === EMPTY_ID ? prevState.tabbableItemId : getRootParentId(focusedItemId);\n      var hoveredItemId = focusedItemId === EMPTY_ID || isIdEmptyOrZeroLevel(prevState.hoveredItemId) && isIdEmptyOrZeroLevel(focusedItemId) ? prevState.hoveredItemId : EMPTY_ID;\n      return {\n        hoveredItemId: hoveredItemId,\n        focusedItemId: focusedItemId,\n        tabbableItemId: tabbableItemId\n      };\n    });\n  };\n\n  Menu.prototype.setHoveredItemId = function (hoveredItemId) {\n    this.setState(function (prevState) {\n      if (isIdEmptyOrZeroLevel(hoveredItemId) && isIdEmptyOrZeroLevel(prevState.focusedItemId)) {\n        return {\n          hoveredItemId: hoveredItemId,\n          focusedItemId: prevState.focusedItemId,\n          tabbableItemId: prevState.tabbableItemId\n        };\n      } else {\n        return {\n          hoveredItemId: hoveredItemId,\n          focusedItemId: EMPTY_ID,\n          tabbableItemId: ZERO_LEVEL_ZERO_ITEM_ID\n        };\n      }\n    });\n  };\n\n  Menu.prototype.getMenuWrapperClassName = function () {\n    return classNames({\n      'k-rtl': this.directionHolder.getIsDirectionRightToLeft()\n    }, this.props.className);\n  };\n\n  Menu.prototype.getMenuClassName = function () {\n    return classNames('k-widget', 'k-reset', 'k-header', 'k-menu', {\n      'k-menu-horizontal': !this.props.vertical\n    }, {\n      'k-menu-vertical': this.props.vertical\n    });\n  };\n\n  Menu.prototype.clearItemHoverAndLeaveRequestsIfApplicable = function () {\n    if (this.itemHoverRequest) {\n      clearTimeout(this.itemHoverRequest);\n      this.itemHoverRequest = null;\n    }\n\n    if (this.itemLeaveRequest) {\n      clearTimeout(this.itemLeaveRequest);\n      this.itemLeaveRequest = null;\n    }\n  };\n\n  Menu.prototype.isItemWithDefaultClose = function (itemId) {\n    return !this.props.customCloseItemIds || this.props.customCloseItemIds.indexOf(itemId) === -1;\n  };\n\n  Menu.prototype.checkIsDirectionRightToLeft = function () {\n    return this.props.dir !== undefined ? this.props.dir === 'rtl' : this.menuWrapperEl && getComputedStyle(this.menuWrapperEl).direction === 'rtl';\n  };\n\n  Menu.prototype.prepareItems = function () {\n    var _a = prepareInputItemsForInternalWork(this.props.items, this.props.children),\n        items = _a.items,\n        inputItems = _a.inputItems;\n\n    this.items = items;\n    this.inputItems = inputItems;\n  };\n\n  Menu.prototype.dispatchSelectEventIfWired = function (event, itemId) {\n    dispatchEvent(this.props.onSelect, event, this, {\n      item: this.getInputItem(itemId),\n      itemId: itemId\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Menu.propTypes = {\n    vertical: PropTypes.bool,\n    items: PropTypes.arrayOf(PropTypes.object),\n    style: PropTypes.object,\n    dir: PropTypes.string,\n    hoverOpenDelay: PropTypes.number,\n    hoverCloseDelay: PropTypes.number,\n    openOnClick: PropTypes.bool,\n    itemRender: PropTypes.any,\n    linkRender: PropTypes.any,\n    customCloseItemIds: PropTypes.arrayOf(PropTypes.string),\n    onSelect: PropTypes.func\n  };\n  /**\n   * @hidden\n   */\n\n  Menu.defaultProps = {\n    vertical: false\n  };\n  return Menu;\n}(React.Component);\n\nexport { Menu };","map":null,"metadata":{},"sourceType":"module"}