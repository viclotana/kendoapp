{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport * as PropTypes from 'prop-types';\nimport { WindowTitleBar } from './WindowTitlebar';\nimport { dispatchEvent, Keys, classNames } from '@progress/kendo-react-common';\nimport { Draggable } from '@progress/kendo-react-common';\nimport { ResizeHandlers } from './WindowResizeHandlers';\nimport { MiddleLayerOptimization } from './MiddleLayerOptimization';\nimport { windowStage } from './StageEnum';\nimport { validatePackage } from '@progress/kendo-licensing';\nimport { packageMetadata } from './package-metadata';\nimport { WindowActionsBar } from './WindowActionsBar';\nvar DEFAULT_WIDTH = 300;\nvar DEFAULT_HEIGHT = 300;\nvar DEFAULT_MIN_WIDTH = 120;\nvar DEFAULT_MIN_HEIGHT = 100;\nvar DEFAULT_STEP = 5;\n\nvar Window =\n/** @class */\nfunction (_super) {\n  __extends(Window, _super);\n\n  function Window(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.offSetCoordinates = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * @hidden\n     */\n\n    _this.onPress = function (data) {\n      var e = data.event;\n      _this.windowCoordinatesState.differenceLeft = e.pageX - _this.left;\n      _this.windowCoordinatesState.differenceTop = e.pageY - _this.top;\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onDrag = function (data) {\n      var e = data.event;\n      e.originalEvent.preventDefault();\n\n      if (_this.windowStage !== windowStage.FULLSCREEN && _this.props.draggable) {\n        _this.setState({\n          top: Math.max(e.pageY - _this.windowCoordinatesState.differenceTop, 0),\n          left: e.pageX - _this.windowCoordinatesState.differenceLeft,\n          isDragging: true\n        });\n\n        if (_this.props.onMove) {\n          _this.dispatchMoveEvent(_this.props.onMove, e, true, false);\n        }\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.onRelease = function (data) {\n      var e = data.event;\n\n      if (_this.windowStage !== windowStage.FULLSCREEN && _this.props.draggable) {\n        if (_this.props.onMove) {\n          _this.dispatchMoveEvent(_this.props.onMove, e, true, true);\n        }\n      }\n\n      _this.setState({\n        isDragging: false\n      });\n    }; // Keyboard navigation\n\n\n    _this.handleKeyDown = function (event) {\n      if (event.target !== event.currentTarget) {\n        return;\n      }\n\n      var minWidth = _this.props.minWidth || DEFAULT_MIN_WIDTH;\n      var minHeight = _this.props.minHeight || DEFAULT_MIN_HEIGHT;\n\n      if (event.ctrlKey && _this.props.resizable) {\n        switch (event.keyCode) {\n          case Keys.up:\n            event.preventDefault();\n\n            if (minHeight <= _this.height - DEFAULT_STEP) {\n              _this.setState({\n                height: _this.height - DEFAULT_STEP\n              });\n            }\n\n            break;\n\n          case Keys.down:\n            event.preventDefault();\n\n            _this.setState({\n              height: _this.height + DEFAULT_STEP\n            });\n\n            break;\n\n          case Keys.left:\n            if (minWidth <= _this.width - DEFAULT_STEP) {\n              _this.setState({\n                width: _this.width - DEFAULT_STEP\n              });\n            }\n\n            break;\n\n          case Keys.right:\n            _this.setState({\n              width: _this.width + DEFAULT_STEP\n            });\n\n            break;\n\n          default:\n            return;\n        }\n\n        _this.dispatchMoveEvent(_this.props.onResize, event, false, undefined);\n\n        return;\n      }\n\n      if (event.altKey) {\n        switch (event.keyCode) {\n          case Keys.up:\n            if (_this.windowStage === windowStage.MINIMIZED) {\n              _this.handleRestore(event);\n\n              dispatchEvent(_this.props.onStageChange, event, _this, {\n                state: windowStage.DEFAULT\n              });\n            } else if (_this.windowStage === windowStage.DEFAULT) {\n              _this.handleFullscreen(event);\n\n              dispatchEvent(_this.props.onStageChange, event, _this, {\n                state: windowStage.FULLSCREEN\n              });\n            }\n\n            break;\n\n          case Keys.down:\n            if (_this.windowStage === windowStage.FULLSCREEN) {\n              _this.handleRestore(event);\n\n              dispatchEvent(_this.props.onStageChange, event, _this, {\n                state: windowStage.DEFAULT\n              });\n            } else if (_this.windowStage === windowStage.DEFAULT) {\n              _this.handleMinimize(event);\n\n              dispatchEvent(_this.props.onStageChange, event, _this, {\n                state: windowStage.MINIMIZED\n              });\n            }\n\n            break;\n\n          default:\n        }\n\n        return;\n      }\n\n      if (!event.ctrlKey) {\n        switch (event.keyCode) {\n          case Keys.esc:\n            if (_this.props.onClose) {\n              event.preventDefault();\n\n              _this.handleCloseWindow(event);\n\n              dispatchEvent(_this.props.onClose, event, _this, {\n                state: undefined\n              });\n            }\n\n            return;\n\n          case Keys.up:\n            _this.setState({\n              top: _this.state.top - DEFAULT_STEP\n            });\n\n            break;\n\n          case Keys.down:\n            _this.setState({\n              top: _this.state.top + DEFAULT_STEP\n            });\n\n            break;\n\n          case Keys.left:\n            _this.setState({\n              left: _this.state.left - DEFAULT_STEP\n            });\n\n            break;\n\n          case Keys.right:\n            _this.setState({\n              left: _this.state.left + DEFAULT_STEP\n            });\n\n            break;\n\n          default:\n            return;\n        }\n      }\n\n      _this.dispatchMoveEvent(_this.props.onMove, event, false, undefined);\n    }; // Get initial coordinates of the Window\n\n\n    _this.getInitialTop = function () {\n      if (_this.props.top !== undefined) {\n        return _this.props.top;\n      }\n\n      if (_this.props.initialTop !== undefined) {\n        return _this.props.initialTop;\n      }\n\n      var height = DEFAULT_HEIGHT;\n\n      if (_this.props.height !== undefined) {\n        height = _this.props.height;\n      } else if (_this.props.initialHeight !== undefined) {\n        height = _this.props.initialHeight;\n      }\n\n      if (_this.props.appendTo) {\n        return _this.props.appendTo.offsetHeight / 2 - height / 2;\n      }\n\n      return window.innerHeight / 2 - height / 2;\n    };\n\n    _this.getInitialLeft = function () {\n      if (_this.props.left !== undefined) {\n        return _this.props.left;\n      }\n\n      if (_this.props.initialLeft !== undefined) {\n        return _this.props.initialLeft;\n      }\n\n      var width = DEFAULT_WIDTH;\n\n      if (_this.props.width !== undefined) {\n        width = _this.props.width;\n      } else if (_this.props.initialWidth !== undefined) {\n        width = _this.props.initialWidth;\n      }\n\n      if (_this.props.appendTo) {\n        return _this.props.appendTo.offsetWidth / 2 - width / 2;\n      }\n\n      return window.innerWidth / 2 - width / 2;\n    };\n\n    _this.getInitialWidth = function () {\n      var width = DEFAULT_WIDTH;\n\n      if (_this.props.width !== undefined) {\n        width = _this.props.width;\n      } else if (_this.props.initialWidth !== undefined) {\n        width = _this.props.initialWidth;\n      }\n\n      return width;\n    };\n\n    _this.getInitialHeight = function () {\n      var height = DEFAULT_HEIGHT;\n\n      if (_this.props.height !== undefined) {\n        height = _this.props.height;\n      } else if (_this.props.initialHeight !== undefined) {\n        height = _this.props.initialHeight;\n      }\n\n      return height;\n    }; // Handle actions\n\n\n    _this.handleMinimize = function (event) {\n      event.preventDefault();\n      _this.windowCoordinatesState.leftBeforeAction = _this.left;\n      _this.windowCoordinatesState.topBeforeAction = _this.top;\n      _this.windowCoordinatesState.widthBeforeAction = _this.width;\n      _this.windowCoordinatesState.heightBeforeAction = _this.height;\n\n      _this.setState({\n        stage: windowStage.MINIMIZED,\n        height: 0\n      });\n\n      dispatchEvent(_this.props.onStageChange, event, _this, {\n        state: windowStage.MINIMIZED\n      });\n    };\n\n    _this.handleFullscreen = function (event) {\n      event.preventDefault();\n      _this.windowCoordinatesState.leftBeforeAction = _this.left;\n      _this.windowCoordinatesState.topBeforeAction = _this.top;\n      _this.windowCoordinatesState.widthBeforeAction = _this.width;\n      _this.windowCoordinatesState.heightBeforeAction = _this.height;\n\n      _this.setState({\n        left: 0,\n        top: 0,\n        width: _this.props.appendTo ? _this.props.appendTo.offsetWidth : window.innerWidth,\n        height: _this.props.appendTo ? _this.props.appendTo.offsetHeight : window.innerHeight,\n        stage: windowStage.FULLSCREEN\n      });\n\n      dispatchEvent(_this.props.onStageChange, event, _this, {\n        state: windowStage.FULLSCREEN\n      });\n    };\n\n    _this.handleRestore = function (event) {\n      event.preventDefault();\n\n      if (_this.windowStage === windowStage.FULLSCREEN) {\n        _this.setState({\n          stage: windowStage.DEFAULT,\n          left: _this.windowCoordinatesState.leftBeforeAction,\n          top: _this.windowCoordinatesState.topBeforeAction,\n          width: _this.windowCoordinatesState.widthBeforeAction,\n          height: _this.windowCoordinatesState.heightBeforeAction\n        });\n      } else if (_this.windowStage === windowStage.MINIMIZED) {\n        _this.setState({\n          stage: windowStage.DEFAULT,\n          height: _this.windowCoordinatesState.heightBeforeAction\n        });\n      }\n\n      dispatchEvent(_this.props.onStageChange, event, _this, {\n        state: windowStage.DEFAULT\n      });\n    };\n\n    _this.handleCloseWindow = function (event) {\n      event.preventDefault();\n      dispatchEvent(_this.props.onClose, event, _this, {\n        state: undefined\n      });\n    };\n\n    _this.handleDoubleClick = function (e) {\n      if (_this.windowStage === windowStage.FULLSCREEN || _this.windowStage === windowStage.MINIMIZED) {\n        _this.handleRestore(e);\n      } else {\n        _this.handleFullscreen(e);\n      }\n    }; // Handle resizing\n\n\n    _this.handleResize = function (event, props) {\n      var x = _this.props.appendTo ? event.pageX - _this.offSetCoordinates.x : event.pageX;\n      var y = _this.props.appendTo ? event.pageY - _this.offSetCoordinates.y : event.pageY;\n      var currentWidth = _this.width;\n      var currentHeight = _this.height;\n      var minWidth = _this.props.minWidth || DEFAULT_MIN_WIDTH;\n      var minHeight = _this.props.minHeight || DEFAULT_MIN_HEIGHT;\n      var heightDifference = _this.top - y;\n      var widthDifference = _this.left - x;\n      var newWidth = x - _this.left;\n      var newHeight = y - _this.top;\n      var newState = Object.assign({}, _this.state, {\n        isDragging: !props.end\n      });\n\n      if (props.direction.indexOf('n') >= 0 && minHeight - (currentHeight + heightDifference) < 0) {\n        if (_this.top > 0) {\n          newState.height = currentHeight + heightDifference;\n        }\n\n        newState.top = y;\n      }\n\n      if (props.direction.indexOf('s') >= 0 && minHeight - newHeight < 0) {\n        newState.height = newHeight;\n      }\n\n      if (props.direction.indexOf('w') >= 0 && minWidth - (currentWidth + widthDifference) < 0) {\n        if (_this.left > 0) {\n          newState.width = currentWidth + widthDifference;\n        }\n\n        newState.left = x;\n      }\n\n      if (props.direction.indexOf('e') >= 0 && minWidth - newWidth < 0) {\n        newState.width = newWidth;\n      }\n\n      _this.setState(newState);\n\n      _this.dispatchMoveEvent(_this.props.onResize, event, true, props.end);\n    }; // Dispatcher for the resize and move events\n\n\n    _this.dispatchMoveEvent = function (callback, event, drag, end) {\n      if (!callback) {\n        return;\n      }\n\n      callback.call(undefined, {\n        nativeEvent: event.nativeEvent ? event.nativeEvent : event.originalEvent,\n        drag: drag,\n        end: end,\n        target: _this,\n        left: _this.state.left,\n        top: _this.state.top,\n        width: _this.state.width,\n        hight: _this.state.height,\n        height: _this.state.height\n      });\n    };\n\n    _this.handleBrowserWindowResize = function () {\n      if (_this.windowStage === windowStage.FULLSCREEN) {\n        _this.setState({\n          width: _this.props.appendTo ? _this.props.appendTo.offsetWidth : window.innerWidth,\n          height: _this.props.appendTo ? _this.props.appendTo.offsetHeight : window.innerHeight\n        });\n      }\n    };\n\n    validatePackage(packageMetadata);\n    _this.state = {\n      stage: _this.props.stage || windowStage.DEFAULT,\n      isDragging: false,\n      top: _this.getInitialTop(),\n      left: _this.getInitialLeft(),\n      width: _this.getInitialWidth(),\n      height: _this.getInitialHeight()\n    };\n    _this.windowCoordinatesState = {\n      leftBeforeAction: _this.getInitialLeft(),\n      topBeforeAction: _this.getInitialTop(),\n      widthBeforeAction: _this.getInitialWidth(),\n      heightBeforeAction: _this.getInitialHeight()\n    };\n    return _this;\n  }\n  /**\n   * @hidden\n   */\n\n\n  Window.prototype.componentDidMount = function () {\n    if (window) {\n      window.addEventListener('resize', this.handleBrowserWindowResize);\n    }\n\n    if (this.props.appendTo) {\n      var containerCoordinates = this.props.appendTo.getBoundingClientRect();\n      var bodyRect = document.body.getBoundingClientRect();\n      this.offSetCoordinates.x = containerCoordinates.left - bodyRect.left;\n      this.offSetCoordinates.y = containerCoordinates.top - bodyRect.top;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Window.prototype.componentWillUnmount = function () {\n    if (window) {\n      window.removeEventListener('resize', this.handleBrowserWindowResize);\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Window.prototype.componentDidUpdate = function () {\n    if (this.props.appendTo) {\n      var containerCoordinates = this.props.appendTo.getBoundingClientRect();\n      var bodyRect = document.body.getBoundingClientRect();\n      this.offSetCoordinates.x = containerCoordinates.left - bodyRect.left;\n      this.offSetCoordinates.y = containerCoordinates.top - bodyRect.top;\n    }\n  };\n  /**\n   * @hidden\n   */\n\n\n  Window.prototype.render = function () {\n    var _this = this;\n\n    var elementsArray = React.Children.toArray(this.props.children);\n    var content = this.getContent(elementsArray);\n    var actions = this.getActionBar(elementsArray);\n    var classNamesWindow = classNames('k-widget', 'k-window', this.props.className, {\n      'k-window-minimized': this.state.stage === 'MINIMIZED'\n    });\n    var windowElement = React.createElement(React.Fragment, null, this.props.modal && React.createElement(\"div\", {\n      className: \"k-overlay\"\n    }), React.createElement(\"div\", {\n      tabIndex: 0,\n      onFocus: function (e) {\n        return e.target.classList.add('k-state-focused');\n      },\n      onBlur: function (e) {\n        return e.target.classList.remove('k-state-focused');\n      },\n      onKeyDown: this.handleKeyDown,\n      ref: function (el) {\n        return _this.windowElement = el;\n      },\n      className: classNamesWindow,\n      style: __assign({\n        top: this.top,\n        left: this.left,\n        width: this.width,\n        height: this.height || ''\n      }, this.props.style)\n    }, React.createElement(MiddleLayerOptimization, {\n      shouldUpdateOnDrag: this.props.shouldUpdateOnDrag || false,\n      isDragging: this.state.isDragging\n    }, React.createElement(Draggable, {\n      onPress: this.onPress,\n      onDrag: this.onDrag,\n      onRelease: this.onRelease,\n      ref: function (component) {\n        return _this.draggable = component;\n      }\n    }, React.createElement(WindowTitleBar, {\n      stage: this.windowStage,\n      onDoubleClick: this.props.doubleClickStageChange ? this.handleDoubleClick : undefined,\n      onMinimizeButtonClick: this.handleMinimize,\n      onFullScreenButtonClick: this.handleFullscreen,\n      onRestoreButtonClick: this.handleRestore,\n      onCloseButtonClick: this.handleCloseWindow,\n      closeButton: this.props.closeButton,\n      minimizeButton: this.props.minimizeButton,\n      maximizeButton: this.props.maximizeButton,\n      restoreButton: this.props.restoreButton\n    }, this.props.title)), this.windowStage !== windowStage.MINIMIZED ? React.createElement(React.Fragment, null, React.createElement(\"div\", {\n      className: \"k-content k-window-content\"\n    }, content), actions) : null, this.windowStage === windowStage.DEFAULT && this.props.resizable ? React.createElement(ResizeHandlers, {\n      onResize: this.handleResize\n    }) : null)));\n\n    if (this.props.appendTo) {\n      return ReactDOM.createPortal(windowElement, this.props.appendTo);\n    }\n\n    return windowElement;\n  };\n\n  Object.defineProperty(Window.prototype, \"top\", {\n    // Getters\n    get: function () {\n      if (this.windowStage !== windowStage.FULLSCREEN) {\n        return Math.max(this.props.top || this.state.top, 0);\n      }\n\n      return 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Window.prototype, \"left\", {\n    get: function () {\n      if (this.windowStage !== windowStage.FULLSCREEN) {\n        return Math.max(this.props.left || this.state.left, 0);\n      }\n\n      return 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Window.prototype, \"width\", {\n    get: function () {\n      var width = this.props.width || this.state.width;\n\n      if (this.windowStage === windowStage.FULLSCREEN) {\n        if (this.props.appendTo) {\n          width = this.props.appendTo.offsetWidth;\n          return width;\n        }\n\n        width = window.innerWidth;\n      }\n\n      return width;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Window.prototype, \"height\", {\n    get: function () {\n      var height = this.props.height || this.state.height;\n\n      if (this.windowStage === windowStage.FULLSCREEN) {\n        if (this.props.appendTo) {\n          height = this.props.appendTo.offsetHeight;\n          return height;\n        }\n\n        height = window.innerHeight;\n      } else if (this.windowStage === windowStage.MINIMIZED) {\n        height = 0;\n      }\n\n      return height;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Window.prototype, \"windowStage\", {\n    get: function () {\n      return this.props.stage || this.state.stage;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Window.prototype.getActionBar = function (children) {\n    return children.filter(function (child) {\n      return child && child.type === WindowActionsBar;\n    });\n  };\n\n  Window.prototype.getContent = function (children) {\n    return children.filter(function (child) {\n      return child && child.type !== WindowActionsBar;\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  Window.propTypes = {\n    id: PropTypes.string,\n    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    left: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    top: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    initialwidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    initialHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    initialLeft: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    initialTop: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    resizable: PropTypes.bool,\n    draggable: PropTypes.bool,\n    title: PropTypes.any,\n    shouldUpdateOnDrag: PropTypes.bool,\n    stage: PropTypes.oneOf(['DEFAULT', 'MINIMIZED', 'FULLSCREEN']),\n    className: PropTypes.string,\n    style: PropTypes.object\n  };\n  /**\n   * @hidden\n   */\n\n  Window.defaultProps = {\n    minWidth: DEFAULT_MIN_WIDTH,\n    minHeight: DEFAULT_MIN_HEIGHT,\n    resizable: true,\n    draggable: true,\n    modal: false,\n    doubleClickStageChange: true\n  };\n  return Window;\n}(React.Component);\n\nexport { Window };","map":null,"metadata":{},"sourceType":"module"}