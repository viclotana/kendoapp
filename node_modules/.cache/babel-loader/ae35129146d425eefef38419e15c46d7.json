{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { classNames, dispatchEvent } from '@progress/kendo-react-common';\nimport { InternalTile } from './InternalTile';\n/**\n * @hidden\n */\n\nvar AUTO_FLOW_CLASSES = {\n  'column': 'k-grid-flow-col',\n  'row': 'k-grid-flow-row',\n  'column dense': 'k-grid-flow-col-dense',\n  'row dense': 'k-grid-flow-row-dense',\n  'unset': 'k-grid-flow-unset'\n};\n/**\n * Represents the [KendoReact TileLayout component]({% slug overview_tilelayout %}).\n */\n\nvar TileLayout =\n/** @class */\nfunction (_super) {\n  __extends(TileLayout, _super);\n\n  function TileLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\n     * @hidden\n     */\n\n\n    _this._element = null;\n    /**\n     * @hidden\n     */\n\n    _this.state = {\n      positions: (_this.props.items || []).map(function (p, i) {\n        return Object.assign({\n          order: i,\n          rowSpan: 1,\n          colSpan: 1\n        }, p.defaultPosition);\n      })\n    };\n    /**\n     * @hidden\n     */\n\n    _this.focus = function () {\n      if (_this._element) {\n        _this._element.focus();\n      }\n    };\n    /**\n     * @hidden\n     */\n\n\n    _this.update = function (index, dOrder, dCol, dRowSpan, dColSpan) {\n      if (dRowSpan === void 0) {\n        dRowSpan = 0;\n      }\n\n      if (dColSpan === void 0) {\n        dColSpan = 0;\n      }\n\n      if (dOrder === 0 && dCol === 0 && !dColSpan && !dRowSpan) {\n        return;\n      }\n\n      var shouldUpdate = false;\n\n      var positions = _this.state.positions.map(function (p) {\n        return Object.assign({}, p);\n      }); // reordering:\n\n\n      var current = positions[index];\n      var other = positions.find(function (item) {\n        return item.order === current.order + dOrder;\n      });\n\n      if (other && other !== current) {\n        current.order += dOrder;\n        other.order += -dOrder;\n        shouldUpdate = true;\n      }\n\n      var proposedCol = current.col + dCol;\n\n      if (dCol !== 0 && proposedCol >= 1 && proposedCol + current.colSpan <= (_this.props.columns || 3) + 1) {\n        current.col = proposedCol;\n        shouldUpdate = true;\n      } // resizing:\n\n\n      var proposedColSpan = current.colSpan + dColSpan;\n\n      if (dColSpan && proposedColSpan >= 1 && proposedColSpan + current.col <= (_this.props.columns || 3) + 1) {\n        current.colSpan = proposedColSpan;\n        shouldUpdate = true;\n      }\n\n      var proposedRowSpan = current.rowSpan + dRowSpan;\n\n      if (dRowSpan && proposedRowSpan >= 1) {\n        current.rowSpan = proposedRowSpan;\n        shouldUpdate = true;\n      }\n\n      if (shouldUpdate) {\n        _this.setState({\n          positions: positions\n        });\n\n        dispatchEvent(_this.props.onReposition, {}, _this, {\n          value: positions\n        });\n      }\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(TileLayout.prototype, \"element\", {\n    /**\n     * Gets the HTML element of the TileLayout component.\n     */\n    get: function () {\n      return this._element;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @hidden\n   */\n\n  TileLayout.getDerivedStateFromProps = function (props, state) {\n    if (props.positions) {\n      // The component is in controlled mode.\n      return {\n        positions: props.positions.map(function (p, i) {\n          return Object.assign({\n            order: i,\n            rowSpan: 1,\n            colSpan: 1\n          }, p);\n        })\n      };\n    }\n\n    if (props.items && (!state.positions || props.items.length !== state.positions.length)) {\n      // The component is in uncontrolled mode.\n      return {\n        positions: props.items.map(function (p, i) {\n          return Object.assign({\n            order: i,\n            rowSpan: 1,\n            colSpan: 1\n          }, p.defaultPosition);\n        })\n      };\n    }\n\n    return null;\n  };\n\n  TileLayout.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        className = _a.className,\n        _b = _a.columns,\n        columns = _b === void 0 ? 3 : _b,\n        _c = _a.columnWidth,\n        columnWidth = _c === void 0 ? '1fr' : _c,\n        gap = _a.gap,\n        _d = _a.rowHeight,\n        rowHeight = _d === void 0 ? '1fr' : _d,\n        style = _a.style,\n        _e = _a.autoFlow,\n        autoFlow = _e === void 0 ? 'column' : _e,\n        _f = _a.items,\n        items = _f === void 0 ? [] : _f;\n    var gapValue = gap ? \"\" + (typeof gap.rows === 'number' ? gap.rows + 'px' : gap.rows) + ' ' + (\"\" + (typeof gap.columns === 'number' ? gap.columns + 'px' : gap.columns)) : 16;\n\n    var tileLayoutStyles = __assign({\n      gridTemplateColumns: \"repeat(\" + columns + \", minmax(0px, \" + (typeof columnWidth === 'number' ? columnWidth + 'px' : columnWidth) + \"))\",\n      gridAutoRows: \"minmax(0px, \" + (typeof rowHeight === 'number' ? rowHeight + 'px' : rowHeight) + \")\",\n      gap: gapValue,\n      padding: gapValue\n    }, style);\n\n    return React.createElement(\"div\", {\n      ref: function (el) {\n        _this._element = el;\n      },\n      dir: this.props.dir,\n      className: classNames('k-tilelayout', AUTO_FLOW_CLASSES[autoFlow], className),\n      style: tileLayoutStyles,\n      id: this.props.id,\n      children: items.map(function (tile, index) {\n        return React.createElement(InternalTile, {\n          key: index,\n          update: _this.update,\n          defaultPosition: _this.state.positions[index],\n          index: index,\n          resizable: tile.resizable,\n          reorderable: tile.reorderable,\n          style: tile.style,\n          className: tile.className,\n          hintClassName: tile.hintClassName,\n          hintStyle: tile.hintStyle\n        }, tile.item ? tile.item : React.createElement(React.Fragment, null, React.createElement(\"div\", {\n          className: \"k-tilelayout-item-header k-card-header\"\n        }, React.isValidElement(tile.header) ? tile.header : React.createElement(\"h5\", {\n          className: 'k-card-title'\n        }, tile.header)), React.createElement(\"div\", {\n          className: 'k-tilelayout-item-body k-card-body'\n        }, tile.body)));\n      })\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  TileLayout.propTypes = {\n    id: PropTypes.string,\n    style: PropTypes.object,\n    className: PropTypes.string,\n    dir: PropTypes.string,\n    gap: PropTypes.object,\n    columns: PropTypes.number,\n    columnWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    items: PropTypes.array,\n    positions: PropTypes.array,\n    autoFlow: PropTypes.oneOf(['column', 'row', 'column dense', 'row dense', 'unset']),\n    onReposition: PropTypes.func\n  };\n  /**\n   * @hidden\n   */\n\n  TileLayout.displayName = 'KendoTileLayout';\n  return TileLayout;\n}(React.Component);\n\nexport { TileLayout };","map":null,"metadata":{},"sourceType":"module"}