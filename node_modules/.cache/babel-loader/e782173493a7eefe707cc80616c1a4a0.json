{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { classNames, Draggable } from '@progress/kendo-react-common';\nimport { ResizeHandlers } from './ResizeHandlers';\n/**\n * @hidden\n */\n\nvar ANIMATION_DURATION = 200;\n/**\n * @hidden\n */\n\nvar InternalTile =\n/** @class */\nfunction (_super) {\n  __extends(InternalTile, _super);\n\n  function InternalTile() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      rtl: false\n    };\n    _this.oldSize = {};\n    _this.draggable = null;\n    _this.dragging = false;\n    _this.resizing = false;\n    _this.element = null;\n    _this.pressOffset = {\n      x: 0,\n      y: 0\n    };\n    _this.pressXY = {\n      x: 0,\n      y: 0\n    };\n    _this.currentTranslate = {\n      x: 0,\n      y: 0\n    };\n    _this.preventDataOps = undefined;\n\n    _this.handleResize = function (e, q) {\n      if (q.end) {\n        _this.handleRelease();\n\n        return;\n      }\n\n      if (!_this.element) {\n        return;\n      }\n\n      var x = e.clientX;\n      var y = e.clientY;\n      _this.resizing = true;\n      var dX = (q.direction !== 'ns' ? x - _this.pressXY.x : 0) * (_this.state.rtl ? -1 : 1);\n      var dY = q.direction !== 'ew' ? y - _this.pressXY.y : 0;\n\n      if (_this.dragElement) {\n        if (_this.state.rtl) {\n          _this.dragElement.style.marginLeft = -dX + 'px';\n        } else {\n          _this.dragElement.style.marginRight = -dX + 'px';\n        }\n\n        _this.dragElement.style.height = \"calc(100% + \" + dY + \"px)\";\n      }\n\n      _this.element.classList.add('k-layout-item-hint', 'k-layout-item-hint-resize');\n\n      if (_this.preventDataOps) {\n        return;\n      }\n\n      var col = 0;\n      var row = 0;\n\n      var wrapBox = _this.element.getBoundingClientRect();\n\n      if (dX > wrapBox.width / _this.props.defaultPosition.colSpan / 3) {\n        col = 1;\n      }\n\n      if (dX < -wrapBox.width / _this.props.defaultPosition.colSpan / 1.25) {\n        col = -1;\n      } // vertical\n\n\n      if (dY > wrapBox.height / _this.props.defaultPosition.rowSpan / 3) {\n        row = 1;\n      }\n\n      if (dY < -wrapBox.height / _this.props.defaultPosition.rowSpan / 1.25) {\n        row = -1;\n      }\n\n      if (col !== 0 || row !== 0) {\n        _this.props.update(_this.props.index, 0, 0, row, col);\n      }\n    };\n\n    _this.handlePress = function (e) {\n      if (!_this.dragElement) {\n        return;\n      }\n\n      if (_this.element) {\n        _this.element.style.zIndex = '10';\n\n        _this.element.classList.add('k-layout-item-hint');\n      }\n\n      _this.dragElement.classList.remove('k-cursor-grab');\n\n      _this.dragElement.classList.add('k-cursor-grabbing');\n\n      var rec = _this.dragElement.getBoundingClientRect();\n\n      _this.pressXY = {\n        x: e.event.clientX,\n        y: e.event.clientY\n      };\n      _this.pressOffset = {\n        x: e.event.clientX - rec.x,\n        y: e.event.clientY - rec.y\n      };\n    };\n\n    _this.handleDrag = function (e) {\n      var dragElement = _this.dragElement;\n\n      if (e.event.originalEvent.defaultPrevented || !dragElement) {\n        return;\n      }\n\n      _this.dragging = true;\n      e.event.originalEvent.preventDefault();\n      var rec = dragElement.getBoundingClientRect();\n      _this.currentTranslate = {\n        x: e.event.clientX - rec.x - _this.pressOffset.x + _this.currentTranslate.x,\n        y: e.event.clientY - rec.y - _this.pressOffset.y + _this.currentTranslate.y\n      };\n      dragElement.style.transform = \"translate(\" + _this.currentTranslate.x + \"px, \" + _this.currentTranslate.y + \"px)\";\n      dragElement.style.transition = 'transform 0s';\n\n      if (_this.preventDataOps) {\n        return;\n      }\n\n      var col = 0;\n      var row = 0;\n\n      if (_this.currentTranslate.y > 0.7 * rec.height / _this.props.defaultPosition.rowSpan) {\n        row = 1;\n      }\n\n      if (_this.currentTranslate.y < 0.7 * -rec.height / _this.props.defaultPosition.rowSpan) {\n        row = -1;\n      }\n\n      if (_this.currentTranslate.x > 0.7 * rec.width / _this.props.defaultPosition.colSpan) {\n        col = 1;\n      }\n\n      if (_this.currentTranslate.x < 0.7 * -rec.width / _this.props.defaultPosition.colSpan) {\n        col = -1;\n      }\n\n      _this.props.update(_this.props.index, row, _this.state.rtl ? -col : col, 0, 0);\n    };\n\n    _this.handleRelease = function () {\n      _this.dragging = _this.resizing = false;\n      _this.currentTranslate = {\n        x: 0,\n        y: 0\n      };\n\n      if (_this.element) {\n        _this.element.style.zIndex = '1';\n\n        _this.element.classList.remove('k-layout-item-hint', 'k-layout-item-hint-resize');\n      }\n\n      var dragElement = _this.dragElement;\n\n      if (dragElement) {\n        dragElement.style.transform = 'translate(0px, 0px)';\n        dragElement.style.transition = \"transform \" + ANIMATION_DURATION + \"ms cubic-bezier(0.2, 0, 0, 1) 0s\";\n        dragElement.style.marginRight = '0px';\n        dragElement.style.marginLeft = '0px';\n        dragElement.style.height = '100%';\n        dragElement.classList.remove('k-cursor-grabbing');\n        dragElement.classList.add('k-cursor-grab');\n      }\n    };\n\n    return _this;\n  }\n\n  Object.defineProperty(InternalTile.prototype, \"dragElement\", {\n    get: function () {\n      return this.draggable ? this.draggable.element : undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  InternalTile.prototype.componentDidMount = function () {\n    if (!this.element) {\n      return;\n    }\n\n    if (getComputedStyle(this.element).direction === 'rtl') {\n      this.setState({\n        rtl: true\n      });\n    }\n  };\n\n  InternalTile.prototype.render = function () {\n    var _this = this;\n\n    if (clearTimeout && typeof clearTimeout === 'function') {\n      clearTimeout(this.preventDataOps);\n      this.preventDataOps = window.setTimeout(function () {\n        _this.preventDataOps = undefined;\n      }, 200);\n    }\n\n    var position = this.props.defaultPosition;\n    var resizable = this.props.resizable !== undefined ? this.props.resizable : InternalTile.defaultProps.resizable;\n    var reorderable = this.props.reorderable !== undefined ? this.props.reorderable : InternalTile.defaultProps.reorderable;\n\n    var itemStyles = __assign({\n      gridColumnStart: position.col,\n      gridColumnEnd: \"span \" + position.colSpan,\n      gridRowStart: position.row,\n      gridRowEnd: \"span \" + position.rowSpan,\n      outline: 'none',\n      order: position.order\n    }, this.props.hintStyle);\n\n    var card = React.createElement(\"div\", {\n      ref: function (e) {\n        _this.draggable = e ? {\n          element: e\n        } : null;\n      },\n      className: classNames('k-tilelayout-item k-card', {\n        'k-cursor-grab': reorderable\n      }, this.props.className),\n      style: __assign({\n        height: '100%'\n      }, this.props.style)\n    }, this.props.children, React.createElement(ResizeHandlers, {\n      onPress: this.handlePress,\n      onResize: this.handleResize,\n      resizable: resizable,\n      rtl: this.state.rtl\n    }));\n    return React.createElement(\"div\", {\n      ref: function (e) {\n        _this.element = e;\n      },\n      style: itemStyles,\n      className: this.props.hintClassName\n    }, reorderable ? React.createElement(Draggable, {\n      ref: function (e) {\n        _this.draggable = e;\n      },\n      onDrag: this.handleDrag,\n      onRelease: this.handleRelease,\n      onPress: this.handlePress\n    }, card) : card);\n  };\n  /**\n   * @hidden\n   */\n\n\n  InternalTile.prototype.getSnapshotBeforeUpdate = function (_) {\n    this.oldSize = {};\n\n    if (this.dragElement) {\n      this.oldSize = this.dragElement.getBoundingClientRect();\n    }\n\n    return null;\n  };\n  /**\n   * @hidden\n   */\n\n\n  InternalTile.prototype.componentDidUpdate = function (prevProps) {\n    var _this = this;\n\n    var dragElement = this.dragElement;\n\n    if (!dragElement) {\n      return;\n    }\n\n    var newBox = dragElement.getBoundingClientRect();\n    var oldBox = this.oldSize;\n\n    if (this.resizing) {\n      var diffCol = newBox.width - oldBox.width;\n\n      if (this.state.rtl) {\n        var currentM = parseFloat(dragElement.style.marginLeft || '0');\n        dragElement.style.marginLeft = currentM - diffCol + 'px';\n      } else {\n        var currentM = parseFloat(dragElement.style.marginRight || '0');\n        dragElement.style.marginRight = currentM + diffCol + 'px';\n      }\n\n      this.pressXY.x += this.state.rtl ? -diffCol : diffCol;\n      var diffRow = newBox.height - oldBox.height;\n      var currentBot = parseFloat(dragElement.style.height.substring(12));\n      dragElement.style.height = \"calc(100% + \" + (currentBot + diffRow) + \"px)\";\n      this.pressXY.y += diffRow;\n    }\n\n    var deltaX = oldBox.left - newBox.left;\n    var deltaY = oldBox.top - newBox.top;\n\n    if (deltaX === 0 && deltaY === 0) {\n      return;\n    }\n\n    if (this.dragging) {\n      if (prevProps.defaultPosition.order !== this.props.defaultPosition.order || prevProps.defaultPosition.col !== this.props.defaultPosition.col) {\n        this.currentTranslate.x = 0;\n        this.currentTranslate.y = 0;\n        dragElement.style.transform = '';\n      }\n\n      return;\n    }\n\n    if (Math.abs(deltaY) < 15 && Math.abs(deltaX) < 15) {\n      // improves performance and removes random flickering\n      return;\n    }\n\n    requestAnimationFrame(function () {\n      var domNode = _this.element;\n\n      if (!domNode) {\n        return;\n      }\n\n      domNode.style.transform = \"translate(\" + deltaX + \"px, \" + deltaY + \"px)\";\n      domNode.style.transition = 'transform 0s';\n      requestAnimationFrame(function () {\n        domNode.style.transform = '';\n        domNode.style.transition = \"transform \" + ANIMATION_DURATION + \"ms cubic-bezier(0.2, 0, 0, 1) 0s\";\n      });\n    });\n  };\n  /**\n   * @hidden\n   */\n\n\n  InternalTile.propTypes = {\n    defaultPosition: PropTypes.object.isRequired,\n    style: PropTypes.object,\n    className: PropTypes.string,\n    hintStyle: PropTypes.object,\n    hintClassName: PropTypes.string,\n    header: PropTypes.any,\n    body: PropTypes.any,\n    item: PropTypes.any,\n    resizable: PropTypes.oneOf(['horizontal', 'vertical', true, false]),\n    reorderable: PropTypes.bool\n  };\n  /**\n   * @hidden\n   */\n\n  InternalTile.displayName = 'KendoTileLayoutItem';\n  /**\n   * @hidden\n   */\n\n  InternalTile.defaultProps = {\n    resizable: true,\n    reorderable: true\n  };\n  return InternalTile;\n}(React.Component);\n\nexport { InternalTile };","map":null,"metadata":{},"sourceType":"module"}